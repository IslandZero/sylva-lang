# number.sylva
#
# provide operations for primitive types
#
# Create by Ryan Guo<ryan@islandzero.net> on 2016/10/04

` #include<math.h>

# Number, virtual class for all primitive types, including integer, float, boolean and nil
#
class Number

  # initializer for 'Number.new', does nothing
  # TODO: add init from string
  func init
    return self
  end

  ####################################################
  # Operations
  ####################################################

  # not operator
  #
  # convert to boolean and returns inverted boolean value
  # alias to 'not' function name

  func !
    ` sl_assert(arguments.length == 0, "wrong number of arguments for operator !, expecting 0, got %ld", arguments.length);
    ` return sl_boolean_value(!sl_to_boolean(self));
  end

  # add operator
  #
  # alias to 'add' function name, support add multiple values

  func +
    ` sl_assert(arguments.length > 0, "wrong number of arguments for operator +, expecting >= 1, got 0");
    ` sl_trans_to_numeric(&self);
    ` // iterate over arguments
    ` for (sl_index i = 0; i < arguments.length; i++) {
    `   sl_value arg = arguments.values[i];
    `   sl_trans_to_numeric(&arg);
    `   switch (arg.type) {
    `   case sl_type_integer: {
    `     // float + integer, integer + integer
    `     if (self.type == sl_type_float) {
    `       self.float_value += arg.integer_value;
    `     } else {
    `       self.integer_value += arg.integer_value;
    `     }
    `   }
    `   break;
    `   case sl_type_float: {
    `     //  integer + float, convert self to float and continue
    `     sl_trans_to_float(&self);
    `     //  float + float
    `     self.float_value += arg.float_value;
    `   }
    `   break;
    `   default:break;
    `   }
    ` }
    ` return self;
  end

  # substract operator
  #
  # alias to function name 'sub'
  # when no arguments are given, returns the reverted value, else returns the minus value

  func -
    ` sl_trans_to_numeric(&self);
    ` //  arguments count == 0, i.e prefix `-` operator
    ` if (arguments.length == 0) {
    `   switch (self.type) {
    `     //  integer
    `   case sl_type_integer: {
    `     self.integer_value = -self.integer_value;
    `   }
    `     break;
    `     //  float
    `   case sl_type_float: {
    `     self.float_value = -self.float_value;
    `   }
    `     break;
    `   default:break;
    `   }
    `   return self;
    ` } else {
    `   //  arguments count != 0, i.e infix `-` operator
    `   for (sl_index i = 0; i < arguments.length; i++) {
    `     //  get the reverted value by recursively invoke SYLVA_Number_I_sub
    `     sl_value reverted = SYLVA_Number_I_sub(arguments.values[i], sl_args_empty);
    `     //  add the reverted value
    `     self = SYLVA_Number_I_add(self, sl_args_make(1, reverted));
    `   }
    `   return self;
    ` }
  end

  # multiply operator
  #
  # support multiple number multiply
  # alias to function name 'mul'

  func *
    ` sl_assert(arguments.length > 0, "wrong number of arguments for operator *, expecting >= 1, got 0");
    ` sl_trans_to_numeric(&self);
    ` for (sl_index i = 0; i < arguments.length; i++) {
    `   sl_value arg = arguments.values[i];
    `   sl_trans_to_numeric(&arg);
    `   switch (arg.type) {
    `   case sl_type_integer: {
    `     //  float * integer
    `     if (self.type == sl_type_float) {
    `       self.float_value *= arg.integer_value;
    `     }
    `     // integer * integer
    `     if (self.type == sl_type_integer) {
    `       self.integer_value *= arg.integer_value;
    `     }
    `   }
    `     break;
    `   case sl_type_float: {
    `     //  integer * float
    `     sl_trans_to_float(&self);
    `     //  float * float
    `     if (self.type == sl_type_float) {
    `       self.float_value *= arg.float_value;
    `     }
    `   }
    `     break;
    `   default:break;
    `   }
    ` }
    ` return self;
  end

  native func /(b)  # alias to `div`
  native func %(b)  # alias to `mod`

  native func <>(b) # alias to `compare`, returns sl_comparison_result
  native func <(b)  # alias to `lt`, bridged to `compare`, returns sl_boolean
  native func >(b)  # alias to `gt`, bridged to `compare`, returns sl_boolean
  native func <=(b) # alias to `lt_eq`, bridged to `compare`, returns sl_boolean
  native func >=(b) # alias to `gt_eq`, bridged to `compare`, returns sl_boolean
  native func ==(b) # alias to `eq`, bridged to `compare`, returns sl_boolean
  native func !=(b) # alias to `not_eq`, bridged to `compare`, returns sl_boolean

  native func ||(b) # alias to `or`, bridged with `sl_to_boolean`
  native func &&(b) # alias to `and`, bridged with `sl_to_boolean`

  native func |(b)  # alias to `bit_or`
  native func &(b)  # alias to `bit_and`
  native func ^(b)  # alias to `bit_xor`
  native func >>(b) # alias to `rshift`
  native func <<(b) # alias to `lshift`
  # Others
  native func abs
  # Common
  native func to_s  # create string representation
end

